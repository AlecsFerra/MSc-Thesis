\section{Merge rules}
\label{chp:join-meet-rules}

When developing software verification tools, the ability to perform multiple 
local reasoning and then merge the results is particularly useful. One example 
of this is the conjunction rule in concurrent separation logic \cite{Brookes16}.

In Hoare logic, the following two rules are sound:

\begin{definition}[Merge rules in Hoare logic] $\;$\\
  \begin{prooftree}
    \AxiomC{$\htriple{P_1}{C}{Q_1}$}
    \AxiomC{$\htriple{P_2}{C}{Q_2}$}
    \RightLabel{$(\lor)$}
    \BinaryInfC{$\htriple{P_1 \lor P_2}{C}{Q_1 \lor Q_2}$}
  \end{prooftree}
  
  \begin{prooftree}$\;$\\
    \AxiomC{$\htriple{P_1}{C}{Q_1}$}
    \AxiomC{$\htriple{P_2}{C}{Q_2}$}
    \RightLabel{$(\land)$}
    \BinaryInfC{$\htriple{P_1 \land P_2}{C}{Q_1 \land Q_2}$}
  \end{prooftree}
\end{definition}

Even though they aren't needed for the completeness of the proof system, performing
two different analyses and then merging the results of them can be actually useful.
Already in \cite{Cousot12}, it was noted that the abstract version of the merge
rules are, in general, unsound in Algebraic Hoare Logic. The same is also true
for Abstract Hoare logic. We will show a counterexample for the $(\lor)$ rule,
but the example can be easily modified for the $(\land)$ rule.

\begin{definition}[Merge rules in Abstract Hoare logic] $\;$\\
  \begin{prooftree}
    \AxiomC{$\atriple{P_1}{C}{Q_1}$}
    \AxiomC{$\atriple{P_2}{C}{Q_2}$}
    \RightLabel{$(\lor)$}
    \BinaryInfC{$\atriple{P_1 \lor P_2}{C}{Q_1 \lor Q_2}$}
  \end{prooftree}
  
  \begin{prooftree}$\;$\\
    \AxiomC{$\atriple{P_1}{C}{Q_1}$}
    \AxiomC{$\atriple{P_2}{C}{Q_2}$}
    \RightLabel{$(\land)$}
    \BinaryInfC{$\atriple{P_1 \land P_2}{C}{Q_1 \land Q_2}$}
  \end{prooftree}
\end{definition}

\begin{example}[Counterexample for the $(\lor)$ rule]
  Let $\atriple[Int]{\cdot}{\cdot}{\cdot}$ be the Abstract Hoare logic 
  instantiation of example \ref{exmp:int-logic}, Interval Logic, and
  let $C \defeq (x = 4? \fcmp x := 50) + (x \neq 4? \fcmp x := x + 1)$. Then we
  can perform the following two derivations:
  \begin{prooftree}
    \AxiomC{$\pi_1$}
    \AxiomC{$\pi_2$}
    \RightLabel{$(+)$}
    \BinaryInfC{$\vdash \atriple[Int]{[3, 3]}{C}{[4, 4]}$}
  \end{prooftree}

  Where $\pi_1$:
  \begin{prooftree}
    \AxiomC{$[3, 3] \leq [3, 3]$}
    \AxiomC{$$}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[3, 3]}{x = 4?}{\bot}$}
    \AxiomC{$$}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{\bot}{x := 50}{\bot}$}
    \RightLabel{$(\fcmp)$}
    \BinaryInfC{$\vdash \atriple[Int]{[3, 3]}{x = 4? \fcmp x := 50}{\bot}$}
    \AxiomC{$\bot \leq [4, 4]$}
    \RightLabel{$(\leq)$}
    \TrinaryInfC{$\vdash \atriple[Int]{[3, 3]}{x = 4? \fcmp x := 50}{[4, 4]}$}
  \end{prooftree}

  And $\pi_2$:
  \begin{prooftree}
    \AxiomC{$$}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[3, 3]}{x \neq 4?}{[3, 3]}$}
    \AxiomC{$$}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[3, 3]}{x := x + 1}{[4, 4]}$}
    \RightLabel{$(\fcmp)$}
    \BinaryInfC{$\vdash \atriple[Int]{[3, 3]}{x \neq 4? \fcmp x := x + 1}{[4, 4]}$}
  \end{prooftree}

  And
  \begin{prooftree}
    \AxiomC{$\pi_3$}
    \AxiomC{$\pi_4$}
    \RightLabel{$(+)$}
    \BinaryInfC{$\vdash \atriple[Int]{[5, 5]}{C}{[6, 6]}$}
  \end{prooftree}

  Where $\pi_3$:
  \begin{prooftree}
    \AxiomC{$[5, 5] \leq [5, 5]$}
    \AxiomC{$$}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[5, 5]}{x = 4?}{\bot}$}
    \AxiomC{$$}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{\bot}{x := 50}{\bot}$}
    \RightLabel{$(\fcmp)$}
    \BinaryInfC{$\vdash \atriple[Int]{[5, 5]}{x = 4? \fcmp x := 50}{\bot}$}
    \AxiomC{$\bot \leq [6, 6]$}
    \RightLabel{$(\leq)$}
    \TrinaryInfC{$\vdash \atriple[Int]{[5, 5]}{x = 4? \fcmp x := 50}{[6, 6]}$}
  \end{prooftree}

  and $\pi_4$:
  \begin{prooftree}
    \AxiomC{$$}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[5, 5]}{x \neq 4?}{[6, 6]}$}
    \AxiomC{$$}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[5, 5]}{x := x + 1}{[6, 6]}$}
    \RightLabel{$(\fcmp)$}
    \BinaryInfC{$\vdash \atriple[Int]{[5, 5]}{x \neq 4? \fcmp x := x + 1}{[6, 6]}$}
  \end{prooftree}

  Thus we can construct the following proof tree:
  \begin{prooftree}
    \AxiomC{$\vdash \atriple{[5, 5]}{C}{[6, 6]}$}
    \AxiomC{$\vdash \atriple{[3, 3]}{C}{[4, 4]}$}
    \BinaryInfC{$\vdash \atriple{[3, 5]}{C}{[4, 6]}$}
  \end{prooftree}

  But clearly, it's unsound as:
  \begin{align*}
    \asem[Int]{C}([3, 5]) &= \asem[Int]{x = 4? \fcmp x := 50}([3, 5])
      \lor \asem[Int]{x \neq 4? \fcmp x := x + 1}([3, 5]) \\
                          &= \bsem{x := 50}^{Int}(\bsem{x = 4?}^{Int}([3, 5]))
      \lor \bsem{x := x + 1}^{Int}(\bsem{x \neq 4?}^{Int}([3, 5])) \\
                          &= [50, 50] \lor [4, 6] \\
                          &= [4, 50]
  \end{align*}

  And $[4, 50] \not \leq [4, 6]$.
\end{example}

Naively, we could think that the issue is only "local" as $\gamma([3]) \cup 
\gamma([5]) = \{3, 5\} \neq \{3, 4, 5\} = \gamma([3] \lor [5])$. Since the least
upper bound is adding new states in the precondition, requiring that
$\gamma(P_1 \lor P_2) = \gamma(P_1) \cup \gamma(P_2)$ might seem enough, but 
actually, it is not true. We can construct arbitrary programs that are able to 
exploit the fact that $\lor$ is generally a convex operation that can add new 
elements.

\begin{definition}[Local $\join$ rule for abstract Hoare logic] $\;$\\
  \begin{prooftree}
    \AxiomC{$\gamma(P_1 \join P_2) = \gamma(P_1) \cup \gamma(P_2)$}
    \AxiomC{$\atriple{P_1}{C}{Q_1}$}
    \AxiomC{$\atriple{P_2}{C}{Q_2}$}
    \RightLabel{$(\join-local)$}
    \TrinaryInfC{$\atriple{P_1 \lor P_2}{C}{Q_1 \lor Q_2}$}
  \end{prooftree}
\end{definition}

\begin{example}[Counterexample for the $(\lor-local)$ rule]
  Let $\atriple[Int]{\cdot}{\cdot}{\cdot}$ be the Abstract Hoare logic 
  instantiation of example \ref{exmp:int-logic}, Interval Logic, and
  let $C \defeq (x = 0? + x = 2?) \fcmp x = 1?$

  Then we can perform the following two derivations:
  \begin{prooftree}
    \AxiomC{$\pi_1$}
    \AxiomC{}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[0, 0]}{x = 1?}{\bot}$}
    \RightLabel{$(\fcmp)$}
    \BinaryInfC{$\vdash \atriple[Int]{[0, 1]}{C}{\bot}$}
  \end{prooftree}

  Where $\pi_1$:
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[0, 1]}{x = 0?}{[0, 0]}$}
    \AxiomC{}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[0, 1]}{x = 2?}{[\bot]}$}
    \AxiomC{$\bot \leq [0, 0]$}
    \RightLabel{$(\leq)$}
    \BinaryInfC{$\vdash \atriple[Int]{[0, 1]}{x = 2?}{[0, 0]}$}
    \RightLabel{$(+)$}
    \BinaryInfC{$\vdash \atriple[Int]{[0, 1]}{(x = 0?) + (x = 2?)}{[0, 0]}$}
  \end{prooftree}

  And
  \begin{prooftree}
    \AxiomC{$\pi_2$}
    \AxiomC{}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[2, 2]}{x = 1?}{\bot}$}
    \RightLabel{$(\fcmp)$}
    \BinaryInfC{$\vdash \atriple[Int]{[2, 2]}{C}{\bot}$}
  \end{prooftree}
  
  Where $\pi_2$:
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[2, 2]}{x = 0?}{[\bot]}$}
    \AxiomC{$\bot \leq [2, 2]$}
    \RightLabel{$(\leq)$}
    \BinaryInfC{$\vdash \atriple[Int]{[2, 2]}{x = 0?}{[2, 2]}$}
    \AxiomC{}
    \RightLabel{$(b)$}
    \UnaryInfC{$\vdash \atriple[Int]{[2, 2]}{x = 2?}{[2, 2]}$}
    \RightLabel{$(+)$}
    \BinaryInfC{$\vdash \atriple[Int]{[2, 2]}{(x = 0?) + (x = 2?)}{[2, 2]}$}
  \end{prooftree}
  
  Thus we can construct the following proof tree:
  \begin{prooftree}
    \AxiomC{$\vdash \atriple{[2, 2]}{C}{\bot}$}
    \AxiomC{$\vdash \atriple{[0, 1]}{C}{\bot}$}
    \BinaryInfC{$\vdash \atriple{0, 2}{C}{\bot}$}
  \end{prooftree}


  But clearly is unsound as:
  \begin{align*}
    \asem[Int]{C}([0, 2]) &= \bsem{x = 1?}^{Int}(\bsem{x = 0?}^{Int}([0, 2]) 
      \join \bsem{x = 2}^{Int}([0, 2])) \\
                          &= \bsem{x = 1?}^{Int}([0, 0] \join [2, 2]) \\
                          &= \bsem{x = 1?}^{Int}([0, 2]) \\
                          &= [1, 1]
  \end{align*}

  And clearly $[1, 1] \not \leq \bot$
\end{example}

This example highlights the actual root cause of the issue: the imprecision
introduced by $\join$, and it has nothing to do with the preconditions. In
particular, we can note that with the program $C' \defeq (x = 1? \fcmp x = 0?)
+ (x = 2? \fcmp x = 0?)$, we don't have the same issue. Even if $C$ and $C'$
are equivalent programs in the concrete domain ($\pow{\pow{\states}}$), they
aren't in the $Int$ domain. Hence, $\asem{(C_1 + C_2) \fcmp C_3} = \asem{(C_1
\fcmp C_3) + (C_2 \fcmp C_3)}$ is not true in general. It's important to note
that this is also one of the axioms in Kleene Algebra with Test \cite{Kozen97},
highlighting how this system can't be described by that.

In particular, we can easily show that for a subset of the precondition (the
precondition that admit a program that can generate them), requiring the
distributivity rule to hold is equivalent to requiring the semantics to be
additive.

\begin{theorem}[Equivalence between additivity and distributivity] $\;$\\
  $\forall \; i \in [1, 3] \;\; \exists \; C_{P_i}$ s.t. 
  $\forall \; Q \;\; \asem{C_{P_i}}(Q) = P_i$

  $$\asem{(C_1 + C_2) \fcmp C_3}(P_1) = \asem{(C_1 \fcmp C_3) + (C_2 \fcmp C_3)}(P_1)$$
  $$\iff$$
  $$\asem{C'}(P_2 \join P_3) = \asem{C'}(P_2) \join \asem{C'}(P_3)$$
\end{theorem}
\begin{proof} $\;$\\
  \begin{itemize}
    \item $(\impliedby)$:
      \begin{align*}
        \asem{(C_1 + C_2) \fcmp C_3}(P_1)
          &= \asem{C_3}(\asem{C_1}(P_1) \join \asem{C_2}(P_1)) \\
          &= \asem{C_3}(\asem{C_1}(P_1)) \join \asem{C_3}(\asem{C_2}(P_1)) \\
          &= \asem{(C_1 \fcmp C_3) + (C_2 \fcmp C_3)}(P_1)
      \end{align*}
    \item $(\implies)$:
      \begin{align*}
        \asem{C'}(P_1 \join P_2) 
          &= \asem{C'}(\asem{C_{P_2}}(Q) \join \asem{C_{P_3}}(Q)) \\
          &= \asem{(C_{P_2} + C_{P_3}) \fcmp C'}(Q) \\
          &= \asem{(C_{P_2} \fcmp C) + (C_{P_3} \fcmp C')}(Q) \\
          &= \asem{C}(\asem{C_{P_2}}(Q)) \join \asem{C}(\asem{C_{P_3}}(Q)) \\
          &= \asem{C}(P_2) \join \asem{C}(P_3)
      \end{align*}
  \end{itemize}
\end{proof}

Hence, we can gain intuition that the $\join$ rule is not working because, in
general, the abstract inductive semantics is not additive, and the root of non
additivity is the non additivity of the base commands.

\begin{theorem}[Additivity of the abstract inductive semantics] $\;$\\
  \label{thm:additivity}
  If $\bsem{b}^A(P_1 \join P_2) = \bsem{b}^A(P_1) \join \bsem{b}^A(P_2)$
  $$\asem{C}(P_1 \join P_2) = \asem{C}(P_1) \join \asem{C}(P_2)$$
\end{theorem}
\begin{proof}
  By structural induction on $C$:
  \begin{itemize}
    \item $\sskip$:
      \begin{align*}
        \asem{\sskip}(P_1 \join P2)
          &= P_1 \join P_2 
          &\text{By definition of $\asem{\cdot}$} \\
          &= \asem{\sskip}(P_1) \join \asem{\sskip}(P_2)
          &\text{By definition of $\asem{\cdot}$} \\
      \end{align*}
    \item $b$:
      \begin{align*}
        \asem{b}(P_1 \join P2)
          &= \bsem{b}^A(P_1 \join P_2)
          &\text{By definition of $\asem{\cdot}$} \\
          &= \bsem{b}^A(P_1) \join \bsem{b}^A(P_2) \\
          &= \asem{b}(P_1) \join \asem{b}(P_2)
          &\text{By definition of $\asem{\cdot}$} \\
      \end{align*}
    \item $C_1 \fcmp C_2$:
      \begin{align*}
        \asem{C_1 \fcmp C_2}(P_1 \join P2)
          &= \asem{C_2}(\asem{C_1}(P_1 \join P_2)) \\
          &\text{By definition of $\asem{\cdot}$} \\
          &= \asem{C_2}(\asem{C_1}(P_1) \join \asem{C_1}(P_2)) \\
          &\text{By inductive hypothesis} \\
          &= \asem{C_2}(\asem{C_1}(P_1)) \join \asem{C_2}(\asem{C_1}(P_2)) \\
          &\text{By inductive hypothesis} \\
          &= \asem{C_1 \fcmp C_2}(P_1) \join \asem{C_1 \fcmp C_2}(P_2) \\
          &\text{By definition of $\asem{\cdot}$} \\
      \end{align*}
    \item $C_1 + C_2$:
      \begin{align*}
        \asem{C_1 \fcmp C_2}(P_1 \join P2)
          &= \asem{C_1}(P_1 \join P_2) \join \asem{C_2}(P_1 \join P_2) \\
          &\text{By definition of $\asem{\cdot}$} \\
          &= \asem{C_1}(P_1) \join \asem{C_1}(P_2) \join \asem{C_2}(P_1)
            \join \asem{C_2}(P_2) \\
          &\text{By inductive hypothesis} \\
          &= \asem{C_1}(P_1) \join \asem{C_2}(P_1) \join \asem{C_1}(P_2)
            \join \asem{C_2}(P_2) \\
          &= \asem{C_1 + C_2}(P_1) \join \asem{C_1 + C_2}(P_2) \\
          &\text{By definition of $\asem{\cdot}$} \\
      \end{align*}
    \item $C^\fix$:
      \begin{align*}
        \asem{C^\fix}(P_1 \join P2)
          &= \lfp(\lambda P' \to P_1 \join P_2 \join \asem{C}(P'))
          &\text{By definition of $\asem{\cdot}$}
      \end{align*}
      Let $F_i \defeq \bsem{C^\fix}(P_i) = \lfp(\lambda P' \to P_i \join 
      \asem{C}(P'))$

      We will show that $F_1 \join F_2$ is the $\lfp$ of the first equation.
      \begin{align*}
        (\lambda P' \to P_1 \join P_2 \join \asem{C}(P'))(F_1 \join F_2)
          &= P_1 \join P_2 \join \asem{C}(F_1 \join F_2) \\
          &= P_1 \join P_2 \join \asem{C}(F_1) \join \asem{C}(F_2)  \\
          &\text{By inductive hypothesis}\\
          &= P_1 \join \asem{C}(F_1) \join P_2 \join \asem{C}(F_2) \\
          &= F_1 \join F_2 \\
          &\text{By definition of $F_i$}\\
          &= \asem{C^\fix}(P_1) \join \asem{C^\fix}(P_2) \\
          &\text{By definition of $F_i$}\\
      \end{align*}

      Now we show that it's also the least one, let $P$ be any fixpoint, 
      $P = P_1 \join P_2 \join \asem{C}(P)$.
      
      Then by definition of $\join$ it follows that $P_i \join \asem{C}(P) \leq 
      P_1 \join P_2 \join \asem{C}(P)$ but by $F_i$ beeing a least fixpoint
      $F_i \leq P_i \join \asem{C}(P)$ thus $F_1 \join F_2 \leq P_1
      \join \asem{C}(P) \join P_2 \join \asem{C}(P) = P_1 \join P_2 \join 
      \asem{C}(P) = P$ hence $F_1 \join F_2$ it's the leas fixpoint.
  \end{itemize}
\end{proof}

We can give a sufficient condition for the addivitivity of the abstract 
inductive semantics:
\begin{theorem}
  \label{thm:gamma-add}
  Let $\langle C, \sqsubseteq \rangle \galoiS{\alpha}{\gamma} \langle A, \leq 
  \rangle$ be a Galois insertion, if $\asem[C]{\cdot}$ and $\gamma$ are 
  additive then the abstract inductive semantics $\asem[A]{\cdot}$ obtained
  via the galois insertion is also additive.
\end{theorem}
\begin{proof}
  \begin{align*}
    \bsem{b}^A(P_1 \join P_2)
      &= \alpha(\bsem{b}^C(\gamma(P_1 \join P_2))) \\
      &= \alpha(\bsem{b}^C(\gamma(P_1))) \join\alpha(\bsem{b}^C(\gamma(P_1))) \\
      &\text{By the additivity of $\gamma$, $\asem[C]{\cdot}$ and $\alpha$}\\
      &= \bsem{b}^A(P_1) \join \bsem{b}^A(P_2)
  \end{align*}

  Then by theorem \ref{thm:additivity} $\asem{\cdot}$ is additive.
\end{proof}

Last we can show that the abstract inductive semantics beeing additive is 
enough to make the $(\join)$ rule sound.

\begin{theorem}[Soundness of the $(\join)$ rule]
  \label{thm:sound-join}
  Let $\asem{\cdot}$ be additive then:
  $$\asem{C}(P_1) \leq Q_1 \text{ and } \asem{C}(P_2) \leq Q_2 \implies
  \asem{C}(P_1 \join P_2) \leq Q_1 \join Q_2$$
\end{theorem}
\begin{proof}
  \begin{align*}
    \asem{C}(P_1 \join P_2)
      &= \asem{C}(P_1) \join \asem{C}(P_2)
      &\text{By additivity of $\asem{\cdot}$} \\
      &\leq Q_1 \join Q_2
  \end{align*}
\end{proof}

The two theorems \ref{thm:sound-join} and \ref{thm:gamma-add} correspond to the
result for Algebraic Hoare logic in which the rule $(\overline{\join})$ is sound
if $\gamma$ is additive.

The same reasoning can be applied for the soundness of the rule $(\meet)$ but
by requiring the semantics to be co-additive. As expected for the abstract
inductive semantics obtained via a a Galois insertion, this boils down to 
requiring $\alpha$ to be co-additive.

