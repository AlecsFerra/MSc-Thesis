\section{Hoare logic for hyperproperties}

\subsection{Introduction to Hyperproperties}

Hyperproperties, introduced in \cite{Clarkson08}, extend traditional program 
properties by considering relationships between multiple executions of a 
program, rather than focusing on individual traces. This concept is essential 
for reasoning about security and correctness properties that involve comparisons 
across different executions, such as non-interference, information flow security, 
and program equivalence.

Standard properties, like those utilized in Hoare logic, are elements of the set 
$\pow{\states}$. In contrast, hyperproperties are elements of the set 
$\pow{\pow{\states}}$ since as said before they encode relation between different
executions. A common example is the property of a program being deterministic. 
Suppose our programs have only one integer variable named \(x\). 
To prove that a program \(C\) is deterministic, we would need to prove an 
infinite number of Hoare triples of the form: for each value of 
\(n \in \mathbb{N}\), there must exist \(m \in \mathbb{N}\) such that 
$\htriple{\{ x = n \}}{C}{\{ x = m \}}$ is valid. Instead, determinism can be 
easily encoded in a single hyper triple: $\htriple{\{ P \in \pow{\pow{\states}} 
\mid |P| = 1 \}}{C}{\{Q \in \pow{\pow{\states}} \mid |Q| = 1\}}$.

\begin{definition}[Strongest Hyper Postcondition]
  The strongest postcondition of a program \(C\) starting from a collection of 
  states \(\chi \in \pow{\pow{\states}}\) is defined as:
  $$\{ \sem{C}(P) \mid P \in \chi \}$$
\end{definition}


\subsection{Inductive Definition of the Strongest Hyper Post Condition}

To obtain a sound and (relative) complete logic for hyperproperties using
our framework, we need to construct an abstract semantics that computes
exactly that property. This problem was already studied in \cite{Mounir17,
Mastroeni18} but in the context of abstract interpretation. In all of them,
what was obtained was an overapproximation of the strongest hyper postcondition
that in abstract interpretation is enough but in our context isn't if we want
to keep the relative completeness. In particular,
the hyper semantics of \texttt{if b then} $C_1$ \texttt{else} $C_2$ is given
as (translated in $\lang$) $\{ \sem{b ? \fcmp C_1} T \cup 
\sem{\neg b ? \fcmp C_2} \mid T \in \mathbb{T}\}$, thus making the definition
non-inductive. In particular, given any program $C$, we can perform the analysis
of \texttt{if true then} $C$ and perform the analysis of any program without 
practically ever using the hyper semantics, and it didn't solve the 
overapproximation problem in loops.

The root of the problem is that in $\pow{\pow{\states}}$ with the standard 
ordering on the powerset, the least upper bound is unable to distinguish between
different executions.

\begin{example}
  \label{exmp:determinism}
  Let $\chi \defeq \{\{1, 2, 3\}, \{5\}\}$. Clearly,
  $$\asem[\pow{\pow{\states}}]{(x := x + 1) + (x := x + 2)}(\chi) = 
  \{\{2, 3, 4\}, \{6\}, \{3, 4, 5\}, \{7\}\},$$
  which is totally different from the strongest hyper postcondition, 
  which is $\{\{2, 3, 4, 5\}, \{6, 7\}\}$.
\end{example}

To our knowledge, there is no literature on an abstract inductive semantics that
exactly computes the strongest hyper postcondition.

\subsection{Hyper Domains}

To address this, we will define a more complex family of domains whose semantics 
satisfy the distributive property of different executions. We will use a set $K$ 
to keep track of each execution and define the join operation in such a way that 
it does not confuse different executions together.

\begin{definition}[Hyper Domain]
  Given a complete lattice $B$ and a set $K$, the hyper domain $H(B)_K$ is 
  defined as:
  $$H(B)_K \defeq K \to B + \textit{undef}.$$

  The complete lattice of $H(B)_K$ is the pointwise lift of the one defined on 
  $B + \text{undef}$, where $B + \text{undef}$ is the complete lattice defined 
  on $B$ with \textit{undef} added as a new bottom element.
\end{definition}

\begin{definition}[Hyper Instantiation]
  Given an instantiation of the abstract inductive semantics on a domain $B$ 
  with semantics of the base commands $\bsem{\cdot}^B$, we can instantiate the 
  abstract inductive semantics for the hyper domain $H(B)_K$ with base 
  commands defined as follows:
  $$\bsem{b}^{H(B)_K}(\chi) \defeq \lambda r \to \bsem{b}^B(\chi(r))$$
\end{definition}

Now we prove that the hyper instantiate is dristibutive:
\begin{theorem}[Distributivity]
    \label{thm:hyper-add}
    $$\asem[H(B)_K]{C}(\mathcal{\chi}) = \lambda r \to \asem[B]{C}(\chi(r))$$
\end{theorem}
\begin{proof}
  By structural induction on $C$:
  \begin{itemize}
    \item $\sskip$:
      \begin{align*}
        \asem[H(B)_K]{\sskip}(\chi) 
          &= \chi \\
          &= \lambda r \to \chi(r) \\
          &= \lambda r \to \asem[B]{\sskip}(\chi(r))
      \end{align*}

    \item $b$:
      \begin{align*}
        \asem[H(B)_K]{b}(\chi) 
          &= \lambda r \to \asem[B]{b}(\chi(r))
      \end{align*}

    \item $C_1 \fcmp C_2$:
      \begin{align*}
        \asem[H(B)_K]{C_1 \fcmp C_2}(\chi) 
          &= \asem[H(B)_K]{C_2}(\asem[H(B)_K]{C_1}(\chi)) \\
          &= \asem[H(B)_K]{C_2}(\lambda r_1 \to 
            \asem[B]{C_1}(\chi(r_1))
          &\text{By inductive hypothesis} \\
          &= \lambda r_2 \to \asem[B]{C_2}(\lambda r_1 \to 
            \asem[B]{C_1}(\chi(r_1))(r_2))
          &\text{By inductive hypothesis} \\
          &= \lambda r_2 \to 
            \asem[B]{C_2}(\asem[B]{C_1}(\chi(r_2))) \\
          &= \lambda r_2 \to \asem[B]{C_1 \fcmp C_2}(\chi(r_2)) \\
      \end{align*}

    \item $C_1 + C_2$:
      \begin{align*}
        \asem[H(B)_K]{C_1 + C_2}(\chi)
          &= \asem[H(B)_K]{C_1}(\chi) 
            \lor \asem[H(B)_K]{C_2}(\chi) \\
          &\text{By inductive hypothesis} \\
          &= (\lambda r_1 \to \asem[B]{C_1}(\chi(r_1)))
            \lor (\lambda r_2 \to \asem[B]{C_1}(\chi(r_2))) \\
          &= \lambda r \to \asem[B]{C_1}(\chi(r))
            \lor \asem[B]{C_2}(\chi(r)) \\
          &= \lambda r \to \asem[B]{C_1 + C_2}(\chi(r))
      \end{align*}

    \item $C^\fix$:
      \begin{align*}
        \asem[H(B)_K]{C^\fix}(\chi)
          &= \lfp(\lambda \psi \to 
            \chi \lor \asem[H(B)_K]{C}(\psi)) \\
          &= \lfp(\lambda \psi \to 
            \chi \lor \lambda r \to \asem[B]{C}(\psi(r)))
          &\text{By inductive hypothesis} \\
          &= \lfp(\lambda \psi \to \lambda r \to
            \chi(r) \lor \asem[B]{C}(\psi(r)))
          &\text{By theorem \ref{th:pointfix}} \\
          &= \lambda r \to \lfp(\lambda P 
            \to \chi(r) \lor \asem[B]{C} P) \\
          &= \lambda r \to \asem[B]{C^\fix}(\chi(r))
      \end{align*}
  \end{itemize}
\end{proof}


\subsection{Inductive definition for Hyper postconditions}

Our goal with the hyper domains was to address the issue caused by taking 
$\pow{\pow{\states}}$ as the domain. However, our abstract inductive semantics 
now uses a different domain. To handle this, we need a way to convert the 
standard representation of hyperproperties to the new one using hyper domains 
and vice versa. To achieve this, we define a pair of functions called the 
conversion pair to perform the operation. Since there could be infinite 
functions converting a standard hyperproperty into the version using hyper 
domains (since we have infinite representation for the same property), we can 
use a single abstraction (an injective function) to represent them all. 
All the results are independent of the chosen indexing function.

\begin{definition}[Conversion Pair]
  Given an injective function $idx : B \to K$, we can 
  define the conversion pair as follows:
  \begin{align*}
    \alpha &\;\;:\; H(B)_K \to \pow{B} \\
    \alpha(\chi) &\defeq \{ \chi(r) \downarrow \; \mid r \in K \} \\
    \\
    \beta &\;\;:\; \pow{B} \to H(B)_K \\
    \beta(\mathcal{X}) &\defeq \lambda r \to \begin{cases}
      P              & \exists P \in \mathcal{X} \; \text{such that} \; idx(P) = r \\
      \textit{undef} & \text{otherwise}
    \end{cases}
  \end{align*}
\end{definition}

By instantiating the hyper domain as $H(\pow{\states})_{\mathbb{R}}$, we will be 
able to prove that the abstract inductive semantics of 
$H(\pow{\states})_{\mathbb{R}}$ computes the strongest hyper postcondition.

We have an infinite amount of injective functions $\pow{\states} \to 
\mathbb{R}$ since if $\states$ is countable then $|\pow{\states}| = 
|\pow{\mathbb{N}}| = |\mathbb{R}|$ thus at least one conversion pair exists,
and since all the results are independent of witch one we choose we won't 
specify one.

Now show that by composing the conversion pair with the abstract 
inductive semantics, we compute exactly the strongest hyper postcondition.
\begin{theorem}[Abstract Inductive Semantics as Strongest Hyper Postcondition]
  \label{thm:hyperpost} 
  $$\alpha(\asem[H(\pow{\states})_\mathbb{R}]{C}(\gamma(\mathcal{X}))) = 
  \{ \asem[\pow{\states}]{C}(P) \mid P \in \mathcal{X} \}$$
\end{theorem}
\begin{proof}
  \begin{align*}
    \alpha(\asem[H(\pow{\states})_\mathbb{R}]{C}(\beta(\mathcal{X})))
      &= \alpha(\lambda r \to \asem[\pow{\states}]{C}(\beta(\mathcal{X})(r)))
      &\text{By Theorem \ref{thm:hyper-add}} \\
      &= \{ \asem[\pow{\states}]{C}(\beta(\mathcal{X})(r))\downarrow \;
        \mid r \in \mathbb{R} \}
      &\text{By the definition of $\alpha$}\\
      &= \{ \asem[\pow{\states}]{C}(P) \mid P \in \mathcal{X} \}
      &\text{By the definition of $\beta$ and injectivity}\\
  \end{align*}
\end{proof}

\subsection{Hyper Hoare triples}
The instantiation provides us with a sound and complete Hoare-like logic 
for hyperproperties when we apply $\alpha$ on the pre and post conditions.

\begin{example}[Determinism in Abstract Hoare Logic]
As explained in Example \ref{exmp:determinism}, we can express that a command is 
deterministic (up to termination) by proving that the hyperproperty 
$\{P \mid |P| = 1\}$ is both a precondition and a postcondition of the command.

Assume that we are working with $\lang$ where assignment involves only one 
variable, so that we can represent states with a single integer.

The encoding of the property that we want to use as a precondition is:
$$\mathcal{P} = \lambda r \to \begin{cases}
  \{ x \} & \exists {x} \in \pow{\states} \; \text{such that} \; idx(P) = r \\
  \textit{undef} & \text{otherwise}
\end{cases}$$

We can prove that the program $\sskip$ is deterministic:
\begin{prooftree}
  \AxiomC{$ $}
  \RightLabel{$(\sskip)$}
  \UnaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {\sskip}{P}$}
\end{prooftree}

Since $\alpha(P) = \{..., \{-1\}, \{0\}, \{1\}, ...\}$, we have proven that the 
command is deterministic.

The same can be done with the increment function:
\begin{prooftree}
  \AxiomC{$ $}
  \RightLabel{$(:=)$}
  \UnaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {x := x + 1}{Q}$}
\end{prooftree}

Where $Q = \lambda r \to \begin{cases}
  \{ x + 1\} & \exists \{x\} \in \pow{\states} \; \text{such that} \; idx(P) = r \\
  \textit{undef} & \text{otherwise}
\end{cases}$

And clearly $\alpha(Q) = \{..., \{0\}, \{1\}, \{2\}, ...\}$, hence proving that the command is deterministic.

We can prove that a non-deterministic choice between two identical programs is 
also deterministic:
\begin{prooftree}
  \AxiomC{$ $}
  \RightLabel{$(:=)$}
  \UnaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {x := x + 1}{Q}$}
  \AxiomC{$ $}
  \RightLabel{$(:=)$}
  \UnaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {x := x + 1}{Q}$}
  \RightLabel{$(+)$}
  \BinaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {(x := x + 1) + (x := x + 1)}{Q}$}
\end{prooftree}

But obviously we cannot do the same with two different programs:
\begin{prooftree}
  \AxiomC{$P \leq P$}
  \AxiomC{$ $}
  \RightLabel{$(\sskip)$}
  \UnaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {\sskip}{P}$}
  \AxiomC{$P \leq P \lor Q$}
  \RightLabel{$(\leq)$}
  \TrinaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {\sskip}{P \lor Q}$}
  \AxiomC{$\pi$}
  \RightLabel{$(+)$}
  \BinaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {\sskip + (x := x + 1)}{P \lor Q}$}
\end{prooftree}

Where $\pi$:
\begin{prooftree}
  \AxiomC{$P \leq P$}
  \AxiomC{$ $}
  \RightLabel{$(:=)$}
  \UnaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {x := x + 1}{Q}$}
  \AxiomC{$Q \leq P \lor Q$}
  \RightLabel{$(\leq)$}
  \TrinaryInfC{$\vdash \atriple[H(\pow{\states})_\mathbb{R}]{P}
    {x := x + 1}{P \lor Q}$}
\end{prooftree}

And clearly $\alpha(P \lor Q) = 
\{..., \{-1, 0\}, \{0, 1\}, \{1, 2\}, ...\}$.
\end{example}

\begin{observation}
  We can clearly see that different elements in the hyper domain correspond to 
  the same hyperproperty. This is an expected behavior since the 
  non-deterministic choice does not, in general, "preserve" hyperproperties. 
  The same trick is performed in other logics that can express hyperproperties 
  by adding a new disjunction operator that splits the condition.
\end{observation}

There is already a sound and (relative) complete Hoare-like logic, Hyper Hoare 
Logic (\cite{Darnier2023}). While arguably more usable since it was developed 
specifically for this goal, it is equivalent to the logic obtained via the 
abstract Hoare logic framework. We can observe that they also had to diverge from 
the usage of the classical disjunction connective (which is equivalent to the 
least upper bound in $\pow{\pow{\states}}$) and had to define an exotic version 
of disjunction ($\otimes$) that is able to distinguish between different 
executions. The resemblance to the least upper bound for the hyperdomains is 
striking.
