@inproceedings{Cousot77,
  author = {Cousot, Patrick and Cousot, Radhia},
  title = {Abstract interpretation: a unified lattice model for static analysis 
    of programs by construction or approximation of fixpoints},
  year = {1977},
  isbn = {9781450373500},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/512950.512973},
  doi = {10.1145/512950.512973},
  abstract = {A program denotes computations in some universe of objects. 
    Abstract interpretation of programs consists in using that denotation to 
    describe computations in another universe of abstract objects, so that the 
    results of abstract execution give some information on the actual 
    computations. An intuitive example (which we borrow from Sintzoff [72]) is 
    the rule of signs. The text -1515 * 17 may be understood to denote 
    computations on the abstract universe {(+), (-), (±)} where the semantics 
    of arithmetic operators is defined by the rule of signs. The abstract 
    execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that 
    -1515 * 17 is a negative number. Abstract interpretation is concerned by a 
    particular underlying structure of the usual universe of computations (the 
    sign, in our example). It gives a summary of some facets of the actual 
    executions of a program. In general this summary is simple to obtain but 
    inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its 
    fundamentally incomplete results abstract interpretation allows the 
    programmer or the compiler to answer questions which do not need full 
    knowledge of program executions or which tolerate an imprecise answer, 
    (e.g. partial correctness proofs of programs ignoring the termination 
    problems, type checking, program optimizations which are not carried in the 
    absence of certainty about their feasibility, …).},
  booktitle = {Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles
    of Programming Languages},
  pages = {238–252},
  numpages = {15},
  location = {Los Angeles, California},
  series = {POPL '77}
}

@techreport{Scott70,
  title = "OUTLINE OF A MATHEMATICAL THEORY OF COMPUTATION",
  author = "Dana Scott",
  year = "1970",
  institution = "OUCL",
  month = "November",
  number = "PRG02",
  pages = "30",
}


@unpublished{Dijkstra74,
  author = "Edsger W. Dijkstra",
  title = "Guarded commands, non-determinacy and a calculus for the derivation 
   of programs",
  month = jun,
  year = "1974",
  note = "see {\cite EWD:EWD472}; circulated privately",
  url = "http://www.cs.utexas.edu/users/EWD/ewd04xx/EWD418.PDF",
}

@article{Cousot12,
  author = {Cousot, Patrick and Cousot, Radhia and Logozzo, Francesco and 
    Barnett, Michael},
  year = {2012},
  month = {10},
  pages = {},
  title = {An Abstract Interpretation Framework for Refactoring with 
    Application to Extract Methods with Contracts},
  volume = {47},
  isbn = {978-1-4503-1561-6},
  journal = {ACM SIGPLAN Notices},
  doi = {10.1145/2384616.2384633}
}


@article{Cook78,
  author = {Cook, Stephen A.},
  title = {Soundness and Completeness of an Axiom System for Program 
    Verification},
  journal = {SIAM Journal on Computing},
  volume = {7},
  number = {1},
  pages = {70-90},
  year = {1978},
  doi = {10.1137/0207005},
  URL = { https://doi.org/10.1137/0207005 },
  eprint = { https://doi.org/10.1137/0207005 },
  abstract = { A simple ALGOL-like language is defined which includes 
    conditional, while, and procedure call statements as well as blocks. A 
    formal interpretive semantics and a Hoare style axiom system are given for 
    the language. The axiom system is proved to be sound, and in a certain sense 
    complete, relative to the interpretive semantics. The main new results are 
    the completeness theorem, and a careful treatment of the procedure call 
    rules for procedures with global variables in their declarations. }
}

@article{Fischer79,
  title = {Propositional dynamic logic of regular programs},
  journal = {Journal of Computer and System Sciences},
  volume = {18},
  number = {2},
  pages = {194-211},
  year = {1979},
  issn = {0022-0000},
  doi = {https://doi.org/10.1016/0022-0000(79)90046-1},
  url = {https://www.sciencedirect.com/science/article/pii/0022000079900461},
  author = {Michael J. Fischer and Richard E. Ladner},
  abstract = {We introduce a fundamental propositional logical system based on 
    modal logic for describing correctness, termination and equivalence of 
    programs. We define a formal syntax and semantics for the propositional 
    dynamic logic of regular programs and give several consequences of the 
    definition. Principal conclusions are that deciding satisfiability of length 
    n formulas requires time dn/logn for some d > 1, and that satisfiability 
    can be decided in nondeterministic time cn for some c. We provide 
    applications of the decision procedure to regular expressions, Ianov schemes, 
    and classical systems of modal logic.}
}

@article{Hoare69,
  author = {Hoare, C. A. R.},
  title = {An axiomatic basis for computer programming},
  year = {1969},
  issue_date = {Oct. 1969},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {12},
  number = {10},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/363235.363259},
  doi = {10.1145/363235.363259},
  abstract = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics.},
  journal = {Commun. ACM},
  month = {oct},
  pages = {576–580},
  numpages = {5},
  keywords = {axiomatic method, formal language definition, machine-independent programming, program documentation, programming language design, theory of programming' proofs of programs}
}


@Inbook{Floyd93,
  author="Floyd, Robert W.",
  editor="Colburn, Timothy R.
  and Fetzer, James H.
  and Rankin, Terry L.",
  title="Assigning Meanings to Programs",
  bookTitle="Program Verification: Fundamental Issues in Computer Science",
  year="1993",
  publisher="Springer Netherlands",
  address="Dordrecht",
  pages="65--81",
  abstract="This paper attempts to provide an adequate basis for formal definitions of the meanings of programs in appropriately defined programming languages, in such a way that a rigorous standard is established for proofs about computer programs, including proofs of correctness, equivalence, and termination. The basis of our approach is the notion of an interpretation of a program: that is, an association of a proposition with each connection in the flow of control through a program, where the proposition is asserted to hold whenever that connection is taken. To prevent an interpretation from being chosen arbitrarily, a condition is imposed on each command of the program. This condition guarantees that whenever a command is reached by way of a connection whose associated proposition is then true, it will be left (if at all) by a connection whose associated proposition will be true at that time. Then by induction on the number of commands executed, one sees that if a program is entered by a connection whose associated proposition is then true, it will be left (if at all) by a connection whose associated proposition will be true at that time. By this means, we may prove certain properties of programs, particularly properties of the form: `If the initial values of the program variables satisfy the relation Rl, the final values on completion will satisfy the relation R2'.",
  isbn="978-94-011-1793-7",
  doi="10.1007/978-94-011-1793-7_4",
  url="https://doi.org/10.1007/978-94-011-1793-7_4"
}


@InProceedings{Moller21,
  author="M{\"o}ller, Bernhard
  and O'Hearn, Peter
  and Hoare, Tony",
  editor="Fahrenberg, Uli
  and Gehrke, Mai
  and Santocanale, Luigi
  and Winter, Michael",
  title="On Algebra of Program Correctness and Incorrectness",
  booktitle="Relational and Algebraic Methods in Computer Science",
  year="2021",
  publisher="Springer International Publishing",
  address="Cham",
  pages="325--343",
  abstract="Variants of Kleene algebra have been used to provide foundations of reasoning about programs, for instance by representing Hoare Logic (HL) in algebra. That work has generally emphasised program correctness, i.e., proving the absence of bugs. Recently, Incorrectness Logic (IL) has been advanced as a formalism for the dual problem: proving the presence of bugs. IL is intended to underpin the use of logic in program testing and static bug finding. Here, we use a Kleene algebra with diamond operators and countable joins of tests, which embeds IL, and which also is complete for reasoning about the image of the embedding. Next to embedding IL, the algebra is able to embed HL, and allows making connections between IL and HL specifications. In this sense, it unifies correctness and incorrectness reasoning in one formalism.",
  isbn="978-3-030-88701-8"
}

