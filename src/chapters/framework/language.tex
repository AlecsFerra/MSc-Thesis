\section{The $\lang$ programming language}

\subsection{Syntax}

The $\lang$ language is inspired by Dijkstra's guarded command languages
\cite{Dijkstra74} with the goal of being as general as possible by being
parametric on a set of \textit{basic commands}. The $\lang$ language is general
enough to describe any imperative non-deterministic programming language.

\begin{definition}[$\lang$ language syntax]
  Given a set $BCmd$ of basic commands, the set on valid $\lang$ programs is 
  defined by the following inductive definition:

  \begin{align*}
    b \in BCmd \\
    \lang \ni C, C_1, C_2 \; & \cceq \sskip        & \text{Skip}\\
                             & \smid b             & \text{Basic command}\\
                             & \smid C_1 \fcmp C_2 & \text{Program composition}\\
                             & \smid C_1 + C_2     & \text{Non deterministic choice}\\
                             & \smid C^\fix        & \text{Iteration}\\
  \end{align*}

  \begin{example} \label{exmp:base-commands-syntax}
    Usually the set of basic commands contains a command to perform tests $e ?$
    discarding executions that do not satisfy the predicate $e$, and $x \ass v$
    to assign the value $v$ to the variable $x$.
  \end{example}
\end{definition}


\subsection{Semantics}

Fixed a set $\states$ of states (usually a collection of associations between
variables names and values) and a family of partial functions $\bsem{\cdot} :
BCmd \to \states \topartial \states$ we can define the denotational semantics
of programs in $\lang$. The \textit{collecting semantics} is defined as a function
$\sem{\cdot} : \lang \to \pow{\states} \to \pow{\states}$ that associates a
program $C$ and a set of initial states to the set of states reached after
executing the program $C$ from the initial states, this is also know as the
predicate transformer semantics \cite{Dijkstra74}.

\begin{definition}[Denotational semantics]
  \label{def:deno}
  Given a set $\states$ of states and a family of partial functions
  $\bsem{\cdot} : BCmd \to \states \topartial \states$ the denotational
  semantics is defined as follows:

  \begin{align*}
      \sem{\cdot}         & \;\;:\; \lang \to \pow{\states} \to \pow{\states} \\
      \sem{\sskip}        &\defeq id \\
      \sem{b}             &\defeq \lambda P . \{ \bsem{b}(p)\downarrow \; \mid 
        p \in P \} \\
      \sem{C_1 \fcmp C_2} &\defeq \sem{C_2} \circ \sem{C_1} \\
      \sem{C_1 + C_2}     &\defeq \lambda P . \sem{C_1} P \cup \sem{C_2} P \\
      \sem{C^\fix}        &\defeq \lambda P . \lfp(\lambda P'. P \cup \sem{C} P')
  \end{align*}

  \begin{example}
    We can define the semantics of the basic commands introduced in 
    \ref{exmp:base-commands-syntax} as:
    $$\bsem{e ?}(\sigma) \defeq \begin{cases}
      \; \sigma & \sigma \models e \\
      \; \uparrow & otherwise
    \end{cases}$$

    Where $\sigma \models e$ means that the state $\sigma$ satisfies the 
    predicate $e$ and $\uparrow$ is denoting that the function is diverging.

    $$\bsem{x \ass e}(\sigma) \defeq \sigma[x/eval(e, \sigma)]$$
    Where $eval$ is some evaluate function for the expressions on the left-hand
    side of assignments and then is substitute in place of $x$ in the 
    state $\sigma$.
  \end{example}

  \begin{theorem}[Monotonicity]
    \label{thm:sem-mono}
    $\forall \; C \in \lang$ $\sem{C}$ is well-defined and monotone.
  \end{theorem}
  \begin{proof}
    We want to prove that $\forall P, Q \in \pow{\states}$ and $C \in \lang$
    $$P \subseteq Q \implies \sem{C}(P) \subseteq \sem{C}(Q)$$
    By structural induction on $C$:
    \begin{itemize}
      \item $\sskip$:
        \begin{align*}
          \sem{\sskip}(P) 
            &= P
            & \text{[By definition of $\sem{\sskip}$]}\\
            &\subseteq Q \\
            &= \sem{\sskip}(Q) 
            & \text{[By definition of $\sem{\sskip}$]}\\
        \end{align*}

      \item $b$:
        \begin{align*}
          \sem{b}(P) 
            &= \{ \bsem{b}(x)\downarrow \; \mid x \in P \} 
            & \text{[By definition of $\sem{b}$]}\\
            &\subseteq \{ \bsem{b}(x)\downarrow \; \mid x \in Q \} 
            & \text{[Since $P \subseteq Q$]}\\
            &= \sem{b}(Q) 
            & \text{[By definition of $\sem{b}$]}\\
        \end{align*}

      \item $C_1 \fcmp C_2$:

        By inductive hypothesis $\sem{C_1}$ is monotone hence
        $\sem{C_1}(P) \subseteq \sem{C_2}(Q)$

        \begin{align*}
          \sem{C_1 \fcmp C_2}(P) 
            &= \sem{C_2}(\sem{C_1}(P))
            &\text{[By definition of $\sem{C_1 \fcmp C_2}$]}\\
            &\subseteq \sem{C_2}(\sem{C_1}(Q))
            &\text{[By inductive hypothesis on $\sem{C_2}$]} \\
        \end{align*}
    
      \item $C_1 + C_2$:
        \begin{align*}
          \sem{C_1 + C_2}(P) 
            &= \sem{C_1}(P) \cup \sem{C_2}(P)
            &\text{[By definition of $\sem{C_1 + C_2}$]}\\
            &\subseteq \sem{C_1}(Q) \cup \sem{C_2}(P)
            &\text{[By inductive hypothesis on $\sem{C_1}$]} \\
            &\subseteq \sem{C_1}(Q) \cup \sem{C_2}(Q)
            &\text{[By inductive hypothesis on $\sem{C_2}$]} \\
            &= \sem{C_1 + C_2}(Q) 
            &\text{[By definition of $\sem{C_1 + C_2}$]}\\
        \end{align*}
      
      \item $C^\fix$:

        \begin{align*}
          \sem{C^\fix}(P) 
            &= \lfp(\lambda P'. P \cup \sem{C}(P'))
            &\text{[By definition of $\sem{C^\fix}$]}\\
            &\subseteq \lfp(\lambda P'. Q \cup \sem{C}(P'))
            &\text{[By theorem \ref{thm:lfp-mono}]}\\
            &= \sem{C^\fix}(Q) 
            &\text{[By definition of $\sem{C^\fix}$]}\\
        \end{align*}
        
        Clearly all the $\lfp$ are well-defined since by inductive hypothesis
        $\sem{C}$ is monotone and $\pow{\states}$ is a complete from 
        \ref{thm:knaster} the least-fixpoint exists.
    \end{itemize}

  \end{proof}

  \begin{observation}
    As observed in \cite{Fischer79} when the set of basic commands contains a 
    command to discard executions we can define the usual deterministic control 
    flow commands as syntactic sugar.

    $$\bm{if} \; b \; \bm{then} \; C_1 \; \bm{else} \; C_2 \defeq (b ? \fcmp C_1) 
    + (\neg b ? \fcmp C_2)$$
    $$\bm{while} \; b \; \bm{do} \; C \defeq (b? \fcmp C)^\fix \fcmp \neg b ?$$
  \end{observation}

  \begin{observation}
    Regular languages of Kleene algebras \cite{Kozen97} usually provide an
    iteration command usually denoted $C^\star$ whose semantics is
    $\sem{C^\star}(P) \defeq \bigcup_{n \in \nat} \sem{C}^n(P)$. This is
    equivalent to $C^\fix$, the reasoning on why a fixpoint formulation was
    chosen will become clear in \ref{obs:abstract-fix}.
  \end{observation}

  \begin{example}
    Let $C \defeq (x \leq 10? \fcmp x := x + 1)^\fix + (x := 55)$ and 
    $P = \{ x = 1 \}$ then we can compute $\sem{C}(P)$ as:
    \begin{align*}
      \sem{C}(P)
        &= \sem{(x \leq 10? \fcmp x := x +1)^\fix}(P) \cup \sem{x := 55}(P) \\
        &= \lfp(\lambda P' . P \cup \sem{x \leq 10? \fcmp x := x + 1}(P'))
          \cup \{x = 55\} \\
        &= \{ x \in \{1, ..., 10\} \} \cup \{x = 55\} \\
        &= \{ x \in \{1, ..., 10, 55\} \}
    \end{align*}
  \end{example}

\end{definition}
